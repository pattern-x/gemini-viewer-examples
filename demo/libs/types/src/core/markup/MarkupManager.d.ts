import * as THREE from "three";
import { BaseMarkup } from "./BaseMarkup";
import { MarkupType } from "./Constants";
import { DrawableData } from "../../core/canvas";
import type { EventInfo, InputManager } from "../../core/input/InputManager";
import { Event } from "../../core/utils";
import type { BaseViewer } from "../../core/viewers";
type MarkupHandler = {};
export declare class MarkupManager extends Event<MarkupHandler> {
    private viewer;
    private inputManager;
    private overlayRender?;
    private drawableList;
    private lineWidth;
    private lineColor;
    private fillColor;
    private fontSize;
    protected mouseDown: boolean;
    protected mouseDownPositionX?: number;
    protected mouseDownPositionY?: number;
    private textInitialPosition?;
    private tempKey?;
    private tempArrowKeys?;
    private selectedShape?;
    private type?;
    private isDrawing;
    private initialDataForEditing?;
    private creatingShape?;
    private tempPoints;
    private textInput?;
    private actived;
    private undoRedoHelper;
    constructor(viewer: BaseViewer, input: InputManager);
    get viewerCanvas(): HTMLCanvasElement;
    get camera(): THREE.OrthographicCamera | THREE.PerspectiveCamera;
    get raycaster(): THREE.Raycaster;
    setMarkupVisibility(id: string, visible: boolean): boolean;
    setMarkupsVisibility(visible: boolean): void;
    clearAll(): void;
    isMarkupActive(): boolean;
    activate(): void;
    deactivate(): void;
    getActiveMarkupType(): MarkupType | undefined;
    setDrawType(type: MarkupType): void;
    setLineWidth(linewidth: number): void;
    getLineWidth(): number;
    setLineColor(color: string): void;
    getLineColor(): string;
    setFillColor(color: string): void;
    getFillColor(): string;
    setFontSize(fontSize: number): void;
    getFontSize(): number;
    pickPositionByScreenPoint(p: THREE.Vector2): THREE.Vector3;
    pickThreejsPositionByMouse(e: EventInfo): THREE.Vector3;
    mousedown: (e: EventInfo) => void;
    mousemove: (e: EventInfo) => void;
    mouseup: (e: EventInfo) => void;
    keydown: (e: EventInfo) => void;
    confirmToRemove(isConfirm: boolean): void;
    isEditing(): boolean;
    endEdit(selectMarkup: BaseMarkup): void;
    endDraw(createdMarkup?: BaseMarkup): void;
    cancelDraw(createdMarkup?: BaseMarkup): void;
    reset(): void;
    render(): void;
    addMarkup(markup: BaseMarkup, needRecord?: boolean): void;
    updateMarkup(markup: BaseMarkup, newData: DrawableData, needRecord?: boolean): void;
    removeMarkup(markup: BaseMarkup, needRecord?: boolean): void;
    removeMarkupById(id: string, needRecord?: boolean): boolean;
    createMarkup(data: DrawableData): BaseMarkup;
    getMarkupById(id: string): BaseMarkup;
    getMarkupData(): DrawableData[];
    setMarkupData(markupShapes: DrawableData[]): void;
    private isCreateLineMode;
    private isCreateDotMode;
    private isCreateTextMode;
    private isCreateShapeMode;
    private drawShape;
    private drawLine;
    private drawText;
    private addInput;
    undo(): void;
    redo(): void;
    clearUndoRedo(): void;
    destroy(): void;
}
export {};
