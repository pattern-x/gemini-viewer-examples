import * as THREE from "three";
import Stats from "three/examples/jsm/libs/stats.module.js";
import { Font } from "three/examples/jsm/loaders/FontLoader.js";
import { CSS2DRenderer } from "three/examples/jsm/renderers/CSS2DRenderer.js";
import { Toolbar } from "../../components/toolbar";
import { DxfModelConfig, DxfViewerConfig, Hotpoint } from "../../core/Configs";
import { Box2, Vector2 } from "../../core/Constants";
import { DrawableData, Drawable } from "../../core/canvas";
import { DxfData, DxfLayer, DxfChange } from "../../core/dxf";
import { ILayoutObject } from "../../core/dxf-parser";
import { EventInfo } from "../../core/input/InputManager";
import { MarkupType, MarkupManager } from "../../core/markup";
import { MeasurementData, MeasurementManager, MeasurementType } from "../../core/measure";
import { BaseViewer, ViewerName } from "../../core/viewers/BaseViewer";
/**
 * Measurements for DxfViewer contains additional information, e.g. layoutName.
 *
 * DxfViewer doesn't maintain the relationship between model and measurement data,
 * business logic should knows which model a set of measurement data belong to.
 */
export interface DxfMeasurementData extends MeasurementData {
    /**
     * Dxf layout name
     */
    layoutName?: string;
}
/**
 * Markup for DxfViewer contains additional information, e.g. layoutName.
 *
 * DxfViewer doesn't maintain the relationship between model and markup data,
 * business logic should knows which model a set of markup data belong to.
 */
export interface DxfMarkupData extends DrawableData {
    layoutName?: string;
}
export interface EntityData {
    modelId: string;
    layoutName: string;
}
/**
 * A group of dxf/dwg layers for a drawing.
 */
export interface DxfLayers {
    modelId: string;
    layers: Record<string, DxfLayer>;
}
/**
 * Threejs objects are organized in tree view as below:
 *
 * - modelLevelObject1              (THREE.Group, name = <modelId>)
 *     - layoutLevelObject1         (THREE.Group, name = <layout name>, used to control layout visibility)
 *         - entityLevelObject1     (THREE.Point/Line/Mesh/Group)
 *
 * - Layer threejs objects
 * {
 *    layerName:[threejsObject1,threejsObject2,threejsObject3,...] (THREE.Point/Line/Mesh)
 * }
 */
/**
 * "dwg" is short for "drawing", it is a file format saved by AutoCAD.
 * And "dxf" is data exchange format, which can be converted from a dwg file.
 * We cannot read dwg directly, and need to convert it to dxf first via ODA.
 *
 * Supported dxf version: AutoCAD 2018. Both binary and ascii are supported.
 *
 * Json Encoding: UTF-8 encoding without BOM
 *
 * Coordinate system: right-handed, y-up
 *
 * About units:
 * - The unit of distance follows the master dxf file's unit
 * - The unit of area follows the master dxf file's unit
 * - The unit of angle is "degree", counterclockwise
 * - The unit of time is "second"
 *
 * Color: use rgb/rgba, values between 0-1
 *
 * About Measurement in DxfViewer:
 * - A measurement is generated by DxfViewer.
 * - Measurements data should be stored by users, so users can restore measurements data into DxfViewer later.
 * - DxfViewer manages measurements data, it can be created, removed, hidden, etc.
 * - A measurement belongs to a layout, DxfViewer maintains the relationship.
 *
 * About Markup in DxfViewer:
 * Markup is pretty similar to measurement.
 *
 * About Hotpoint in DxfViewer:
 * - A hotpoint is created and stored by user.
 * - A hotpoint can be added to, and removed from DxfViewer.
 * - DxfViewer doesn't hide a hotpoint, user is able to do it.
 * - DxfViewer doesn't maintain the relationship between hotpoint and layout.
 *
 * @example
 * ``` typescript
 * const viewerCfg = {
 *     containerId: "myCanvas",
 *     enableToolbar: true,
 *     enableSpinner: true,
 *     enableLayoutBar: true,
 * };
 * const modelCfg = {
 *     modelId: "id_0",
 *     name: "sample",
 *     src: "http://www.abc.com/sample.dxf",
 * }
 * const fontFiles = ["http://www.abc.com/hztxt.shx", "http://www.abc.com/simplex.shx"];
 * const viewer = new DxfViewer(viewerCfg);
 * await viewer.setFont(fontFiles);
 * await viewer.loadModelAsync(modelCfg);
 * ```
 */
export declare class DxfViewer extends BaseViewer {
    /**
     * @internal
     */
    name: ViewerName;
    private readonly CAMERA_Z_POSITION;
    private readonly CAMERA_MIN_ZOOM;
    private timer;
    protected css2dRenderer?: CSS2DRenderer;
    protected font?: Font;
    protected enableSelection?: boolean;
    protected selectedObject?: THREE.Object3D | Drawable;
    protected stats?: Stats;
    /**
     * The record "key" is modelId or src.
     * @internal
     */
    loadedModels: Record<string, {
        dxfData?: DxfData;
        msTransformMatrix?: THREE.Matrix4;
    }>;
    private masterModelId;
    private dxfLayoutBar?;
    private raycaster?;
    private cameraUpdateInterval?;
    private mouseMoved;
    private mouseDoubleClicked;
    protected selected: boolean;
    private measurementManager?;
    private markupManager?;
    private zoomToRectHelper?;
    private boxSelectHelper?;
    private raf?;
    private clock;
    protected renderEnabled: boolean;
    private timeoutSymbol?;
    private spinner?;
    private loadingProgressBar?;
    private jobCount;
    private contextMenu?;
    private axes?;
    /**
     * @internal
     */
    toolbar?: Toolbar<DxfViewer>;
    private bottomBar?;
    private enableHideVisuallySmallObjects;
    private sortedHidableObjects;
    private lastCameraZoom;
    private activeLayoutName;
    private layoutInfos;
    private units;
    private raycastableObjects;
    private changes;
    private fpsUtils;
    protected hotpointRoot?: THREE.Group;
    constructor(viewerCfg: DxfViewerConfig);
    /**
     * Initialize everything it needs
     * @internal
     */
    protected init(): void;
    private initInputManager;
    private initThree;
    private initDom;
    private initScene;
    private initRenderer;
    protected initCSS2DRenderer(): void;
    /**
     * @internal
     */
    private initCamera;
    /**
     * @internal
     */
    protected initControls(): void;
    private onResize;
    protected onControlsChange(viewer: DxfViewer): () => void;
    protected onControlsEnd(viewer: DxfViewer): () => void;
    private initSpinner;
    /**
     * Initialize mouse/pointer events
     */
    private initEvents;
    protected initOthers(): void;
    private initAxes;
    private initStats;
    /**
     * Shows the stats panel, which indicates current FPS, MS, MB, etc.
     * @internal
     */
    showStats(): void;
    /**
     * Shows the stats panel, which indicates current FPS, MS, MB, etc.
     * @internal
     */
    hideStats(): void;
    private initToolbar;
    private initBottomBar;
    private initLoadingProgressBar;
    /**
     * Shows the layout bar
     * @internal
     */
    showLayoutBar(): void;
    /**
     * Hides the layout bar
     * @internal
     */
    hideLayoutBar(): void;
    protected animate(): void;
    /**
     * In order to have a better performance, it should only render when necessary.
     * Usually, we should enable render for these cases:
     *  - Anything added to, removed from scene, or objects' position, scale, rotation, opacity, material, etc. changed
     *  - Anything selected/unselected
     *  - Camera changed
     *  - Render area resized
     * @internal
     */
    enableRender: (time?: number) => void;
    /**
     * Gets current FPS value
     * @internal
     */
    getFps(): number;
    /**
     * @internal
     */
    is3d(): boolean;
    /**
     * Destroies DxfViewer
     */
    destroy(): void;
    /**
     * Used to indicate how many dxf is loading
     */
    private loadingDxfCount;
    /**
     * Loads a dxf file.
     * The first loaded file will be taken as a "master" model.
     * Any other files are non-master, we call "overlay" model.
     * We'll load everything of a master model, including model and paper space.
     * For an overlay model, we'll only load its model space. And its model space can only
     * overly to master model's model space.
     * @example
     * ``` typescript
     * const viewerCfg = {
     *     containerId: "myCanvas",
     * };
     * const modelCfg = {
     *     modelId: "id_0",
     *     name: "dxf 0",
     *     src: "http://www.abc.com/sample.dxf",
     * }
     * const viewer = new DxfViewer(viewerCfg);
     * await viewer.loadModelAsync(modelCfg, (event) => {
     *     const progress = (event.loaded * 100) / event.total;
     *     console.log(`${event.type}: ${progress}%`);
     * });
     * console.log("Loaded");
     * ```
     */
    loadModelAsync(modelCfg: DxfModelConfig, onProgress?: (event: ProgressEvent) => void): Promise<void>;
    /**
     * Unloads a dxf
     * @internal
     */
    unloadDxf(): void;
    /**
     * If it is under compare mode
     */
    private compareMode;
    /**
     * If it is under compare mode
     * @internal
     */
    isCompareMode(): boolean;
    /**
     * Compares two dxf files. Note that:
     * - It only compares model spaces.
     * - It shouldn't load anything else before and after compare.
     * @param model1 The first dxf to be compared
     * @param model2 The second dxf to be compared
     * @param onProgress loading progress
     * @internal
     */
    compare(model1: DxfModelConfig, model2: DxfModelConfig, onProgress?: (event: ProgressEvent) => void): Promise<void>;
    /**
     * Gets loaded entity count
     * @internal
     * @returns {number}
     */
    getEntitiesCount(): number;
    /**
     * Gets loaded dxf model id array
     */
    protected getLoadedDxfModelIds(): string[];
    /**
     * Gets layouts
     */
    getLayoutNames(): string[];
    /**
     * Gets layouts.
     * Only returns master model's layouts.
     */
    protected getLayouts(): ILayoutObject[];
    private handleOverlayDxf;
    /**
     * Activates a layout
     */
    activateLayout(layoutName: string): void;
    /**
     * Calculates the boundingBox of objects with child objects in the children of layoutLevelObject
     */
    private calcBoundingBoxOfLayoutChild;
    /**
     * Gets active layout
     */
    getActiveLayoutName(): string | undefined;
    /**
     * Gets dxf layers.
     * @example
     * ``` typescript
     * const dxfLayers = viewer.getLayers();
     * for (let i = 0; i < dxfLayers.length; ++i) {
     *     const layers = dxfLayers[i].layers;
     *     const layerNames = Object.keys(layers).sort();
     *     console.log(layerNames);
     * }
     * ```
     */
    getLayers(): DxfLayers[];
    /**
     * Sets model's (aka, a dxf file) visibility.
     * @throws Throws exception if modelId doesn't exist.
     * @internal
     */
    setModelVisibility(modelId: string, visible: boolean): void;
    /**
     * Sets layer's visibility.
     * @param layerName Layer's name to show or hide
     * @param visible Layer's target visibility
     * @param modelId Useful when more than one model is loaded, if not specified, will use the master model.
     * @throws Throws exception if given modelId doesn't exist.
     * @example
     * ``` typescript
     * // Hides layer "0"
     * viewer.setLayerVisibility("0", false);
     * ```
     */
    setLayerVisibility(layerName: string, visible: boolean, modelId?: string): void;
    /**
     * Sets layer's opacity
     * @internal
     */
    setLayerOpacity(): void;
    /**
     * Sets layer's color
     * @throws Throws exception if layer doesn't exist.
     * @internal
     */
    setLayerColor(layerName: string, color: number, modelId?: string): void;
    resetLayerColor(layerName: string, modelId?: string): void;
    /**
     * Sets font.
     * This needs to be called before loading a dxf, it won't affect any loaded text.
     * It accepts shx or typeface formats. For typeface, it only support passing in 1 font file in the array for now.
     * @param urls font file urls
     */
    setFont(urls: string[]): Promise<void>;
    /**
     * Sets display length units.
     * @internal Not implemented yet!
     * @default Millimeters
     */
    setDisplayLengthUnits(): void;
    /**
     * Sets display area units
     * @internal Not implemented yet!
     * @default Meters
     */
    setDisplayAreaUnits(): void;
    /**
     * Sets display decimal digits
     * @internal Not implemented yet!
     * @default 2
     */
    setDisplayPrecision(): void;
    /**
     * Gets current view extent.
     * This is useful for user to save this value as a viewpoint, and jump to this viewpoint next time.
     */
    getCurrentViewExtent(): Box2;
    /**
     * Box selects an area and get the screenshot in format of base64 string.
     */
    getScreenshot(): Promise<undefined | string>;
    /**
     * @internal
     */
    getMeasurementManager(): MeasurementManager | undefined;
    /**
     * Activates one of "Distance", "Area" or "Angle" measurement
     * @param type "Distance", "Area" or "Angle"
     * @example
     * ``` typescript
     * viewer.activateMeasurement(MeasurementType.Distance);
     * ```
     */
    activateMeasurement(type: MeasurementType): void;
    /**
     * Deactivates measurement
     */
    deactivateMeasurement(): void;
    /**
     * Gets active measurement type
     */
    getActiveMeasurementType(): MeasurementType | undefined;
    /**
     * Gets all measurements
     * @example
     * ``` typescript
     * const measurementData = viewer.getMeasurements();
     * console.log(measurementData);
     * ```
     */
    getMeasurements(): DxfMeasurementData[];
    /**
     * Sets measurement data.
     * User can set measurement data for all layouts, DxfViewer manages their visibilities
     * for different layouts.
     * @example
     * ``` typescript
     * const measurementData = [{
     *     type: "Distance",
     *     id: "c6ea70a3-ddb0-4dd0-87c8-bd2491936428",
     *     points: [[0, 1000], [5000, 1000]],
     *     layoutName: "Model",
     * }];
     * viewer.setMeasurements(measurementData);
     * ```
     */
    setMeasurements(measurementData: DxfMeasurementData[]): void;
    /**
     * Selects a measurement by id
     * @internal
     */
    selectMeasurement(id: string): void;
    /**
     * Unselects a measurement by id
     * @internal
     */
    unselectMeasurement(): void;
    /**
     * Removes a measurement
     */
    removeMeasurement(id: string): void;
    /**
     * Sets a measurement's visibility.
     * Note that, the markup should belong to active layout. You shouldn't update a markup of an inactive layout.
     * @internal
     */
    setMeasurementVisibility(id: string, visible: boolean): boolean;
    /**
     * Clears measurement results for all layouts
     */
    clearMeasurements(): void;
    /** markup start **/
    /**
     * @internal
     */
    getMarkupManager(): MarkupManager | undefined;
    /**
     * Activates markup feature
     * @param type MarkupType
     * @example
     * ``` typescript
     * viewer.activateMarkup(MarkupType.Arrow);
     * ```
     */
    activateMarkup(type: MarkupType): void;
    /**
     * Deactivates markup
     */
    deactivateMarkup(): void;
    /**
     * Gets active markup type
     */
    getActiveMarkupType(): MarkupType | undefined;
    /**
     * Set markup stroke color
     * @internal
     */
    setMarkupLineColor(color: string): void;
    /**
     * @internal
     */
    getMarkupLineColor(): string | undefined;
    /**
     * Set markup fill color
     * @internal
     */
    setMarkupFillColor(color: string): void;
    /**
     * @internal
     */
    getMarkupFillColor(): string | undefined;
    /**
     * Set markup stroke line width
     * @internal
     */
    setMarkupLineWidth(lineWidth: number): void;
    /**
     * @internal
     */
    getMarkupLineWidth(): number | undefined;
    /**
     * Set markup font size
     * @internal
     */
    setMarkupFontSize(fontSize: number): void;
    /**
     * @internal
     */
    getMarkupFontSize(): number | undefined;
    /**
     * Gets all markups
     * @returns DxfMarkupData array
     */
    getMarkups(): DxfMarkupData[];
    /**
     * Sets markup data.
     * User can set markup data for all layouts, DxfViewer manages their visibilities for different layouts.
     * @example
     * ``` typescript
     * const markupData = [{
     *     type: "ArrowMarkup",
     *     id: "c6ea70a3-ddb0-4dd0-87c8-bd2491936428",
     *     lineWidth: 2,
     *     strokeStyle: "#ff0000",
     *     fillStyle: "#ff000030",
     *     points: [[0, 0], [1000, 1000]],
     *     layoutName: "Model",
     * }];
     * viewer.setMarkups(markupData);
     * ```
     */
    setMarkups(markupDataArray: DxfMarkupData[]): void;
    /**
     * Sets a markup's visibility by id.
     * Note that, the markup should belong to active layout. You shouldn't update a markup of an inactive layout.
     * @internal
     */
    setMarkupVisibility(id: string, visible: boolean): boolean;
    /**
     * Updates a markup.
     * Note that, you are able to update a markup of an inactive layout. But, you can see nothing happen from ui.
     */
    updateMarkup(markup: DxfMarkupData): boolean;
    /**
     * Removes a markup by markup id.
     * Note that, you are able to delete a markup of an inactive layout. But, you can see nothing happen from ui.
     */
    removeMarkup(id: string): boolean;
    /**
     * Clears markups for all layouts
     */
    clearMarkups(): void;
    /** markup end **/
    /**
     * Adds a hotpoint.
     */
    addHotpoint(hotpoint: Hotpoint): void;
    /**
     * Removes a hotpoint
     */
    removeHotpoint(hotpointId: string): void;
    /**
     * Clears all hotpoints from all layouts
     */
    clearHotpoints(): void;
    /**
     * Checks if hotpoint with specific id already exist
     * @internal
     */
    hasHotpoint(hotpointId: string): boolean;
    /**
     * Gets mouse hit result in world coordinate
     * @example
     * ``` typescript
     * document.addEventListener("click", (event) => {
     *     const result = viewer.getHitResult(event);
     *     const loc = result?.location;
     *     if (loc) {
     *         console.log(`Clicked at x: ${loc[0]}, y: ${loc[1]}`);
     *     }
     * });
     * ```
     * @internal
     */
    getHitResult(event: MouseEvent | PointerEvent | EventInfo): Vector2 | undefined;
    /**
     * Gets hit result by Normalized Device Coordinates.
     * Lower left coordinate: (-1, -1)
     * Upper right coordinate: (1, 1)
     */
    protected getHitResultByNdcCoordinate(coord: Vector2): Vector2 | undefined;
    /**
     * Asks user to select a box area, and zooms to it.
     */
    zoomToRect(): void;
    /**
     * @internal
     */
    deactivateZoomRect(): void;
    /**
     * draw compare markups
     */
    private getLayoutByName;
    private getActiveLayoutInfo;
    private getMsTransformMatrix;
    private switchTransformMs;
    private getLayoutExtentEx;
    private getModelSpaceExtent;
    private getLayoutExtent;
    /**
     * Shows objects for given layout, and hide any other layouts.
     */
    private showLayoutObjects;
    private getLayoutViewports;
    private setMaterialUniforms;
    /**
     * Checks if a layer is frozen for viewport (VP Freeze)
     */
    private isLayerFrozenForViewport;
    private getFilteredViewports;
    private generateObjectsByViewport;
    private findSpatialFilter;
    private getAnyMaterial;
    private addSpatialFilterSection;
    private getObjectsByBoundingBox;
    private getDxfUnits;
    private generateSectionsBySpatialFilter;
    /**
     * Add newly added object to scene.
     * Also, usually(but not always) we should regenerate sky and go to home view
     * @param object
     */
    private addLoadedModelToScene;
    protected resize(width?: number, height?: number): void;
    /**
     * @internal
     */
    getRaycaster(): THREE.Raycaster | undefined;
    /**
     * Gets raycast-able objects.
     * Raycast-able objects should be visible objects in scene.
     */
    private getRaycastableObjects;
    /**
     * Gets the corresponding viewport by judging that the point is in the viewport
     */
    private getViewportByPoint;
    /**
     * Gets raycast-able objects by mouseEvent.
     * @internal
     */
    getRaycastableObjectsByMouse(event?: EventInfo): THREE.Object3D<THREE.Event>[];
    /**
     * Gets intersections by given mouse location.
     * If no MouseEvent is passed in, use (0, 0) as the raycaster's origin.
     */
    private getIntersections;
    /**
     * Handles mouse click event
     */
    private handleMouseClick;
    private selectDrawableByEvent;
    /**
     * Select or unselect an object.
     */
    protected selectObject(object?: THREE.Object3D, depthTest?: boolean): void;
    /**
     * Clears the current selection
     */
    protected clearSelection(): void;
    /**
     * Makes camera fly to objects
     */
    protected flyToObjects(objects: THREE.Object3D[]): void;
    /**
     * Make camera fly to an object
     */
    protected flyToObject(object: THREE.Object3D): void;
    /**
     * Flies to current selected object if any
     */
    protected flyToSelectedObject(): void;
    /**
     * Flies to a random object (by alt + r).
     * It is useful when either the data is wrong or there is bug in program,
     * then we cannot see anything in the scene!
     */
    protected flyToRandomObject(): void;
    /**
     * Makes camera fly to target position with given lookAt position
     * @param position camera's target position
     * @param lookAt camera's new lookAt position
     * @param targetCameraZoom camera's target zoom value
     * @internal
     */
    flyTo(position: THREE.Vector3, lookAt: THREE.Vector3, targetCameraZoom?: number, animate?: boolean): void;
    /**
     * Moves camera to target position
     * @param position 2d position
     */
    goTo(position: Vector2, targetCameraZoom?: number, animate?: boolean): void;
    /**
     * Moves camera to home view
     */
    goToHomeView(): void;
    /**
     * Zooms to specific bounding box
     * @internal
     */
    zoomToBBox(bbox: Box2): void;
    /**
     * Zooms to view extent
     */
    zoomToExtent(): void;
    /**
     * Zooms to a compare change
     * @param changeId Change data id
     */
    zoomToCompareChange(changeId: number): void;
    /**
     * Gets compare changes
     */
    getCompareChanges(): Record<string, DxfChange> | undefined;
    /**
     * Sets background color
     * @param r value between 0-1
     * @param g value between 0-1
     * @param b value between 0-1
     * @example
     * ``` typescript
     * // Sets background to gray
     * viewer.setBackgroundColor(0.5, 0.5, 0.5);
     * ```
     */
    setBackgroundColor(r: number, g: number, b: number): void;
    /**
     * Sets spinner visibility
     */
    protected setSpinnerVisibility(visible: boolean): void;
    /**
     * Increases job count, and show spinner accordingly
     */
    protected increaseJobCount(): void;
    /**
     * Decreases job count, and hide spinner accordingly
     */
    protected decreaseJobCount(): void;
    /**
     * Gets LayoutInfo by layoutName. It creats LayoutInfo if doesn't exist.
     */
    private getLayoutInfo;
    /**
     * Creates a ground plane which is much bigger than bbox.
     */
    private updateGroundPlane;
    /**
     * Compute bounding box of loaded models for active layout
     * @internal
     */
    computeBoundingBox(): THREE.Box3;
    /**
     * Checks if an expected zoom value is valid, and adjust its value if necessary.
     */
    private checkAndGetLimitedCameraZoom;
    /**
     * Set the visibility of dxf objects based on the camera frustum.
     * TODO: the visibility of the children of modelspace or paperspace objects
     */
    private setVisibilityByCameraFrustum;
    private getVisiblePixelSize;
    private setLayoutHidableObjectArray;
    private statObjects;
    /**
     * Updates hidable objects' visibility once camera.zoom changed.
     */
    private updateHidableObjectsVisibility;
    /**
     * Updates raycaster threshold to a proper value, so user can easily pick points and lines
     */
    private updateRaycasterThreshold;
    /**
     * Updates camera zoom value for shader materials, which are created in DxfLoader
     */
    private updateCameraZoomUniform;
}
