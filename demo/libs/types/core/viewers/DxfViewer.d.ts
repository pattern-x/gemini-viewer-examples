import * as THREE from "three";
import { BaseViewer } from "./BaseViewer";
import { ViewerName } from "./Constants";
import { DxfModelConfig, DxfViewerConfig } from "../../core/Configs";
import { Box2, Vector2 } from "../../core/Constants";
import { Drawable, DrawableData } from "../../core/canvas";
import { DxfLayer } from "../../core/dxf";
import { EventInfo } from "../../core/input/InputManager";
import { MarkupManager, MarkupType } from "../../core/markup";
import { Model2d } from "../../core/model";
/**
 * Markup for DxfViewer contains additional information, e.g. layoutName.
 *
 * DxfViewer doesn't maintain the relationship between model and markup data,
 * business logic should knows which model a set of markup data belong to.
 */
export declare type MarkupData = DrawableData;
export interface EntityData {
    modelId: string;
    layerName: string;
}
/**
 * A group of dxf/dwg layers for a drawing.
 */
export interface DxfLayers {
    modelId: string;
    layers: Record<string, DxfLayer>;
}
export interface PdfLayers {
    modelId: string;
    layers: Record<string, PdfLayer>;
}
export interface PdfLayer {
    name: string;
    id: string;
    index: string;
    visible: boolean;
}
export interface PdfData {
    threejsObject: THREE.Object3D;
    layers: Record<string, PdfLayer>;
    layersAndThreejsObjects?: Record<string, THREE.Object3D[]>;
    loadedEntityCount: number;
}
/**
 * Threejs objects are organized in tree view as below:
 *
 * - modelLevelObject1              (THREE.Group, name = <modelId>)
 *     - layoutLevelObject1         (THREE.Group, name = <layout name>, used to control layout visibility)
 *         - entityLevelObject1     (THREE.Point/Line/Mesh/Group)
 *
 * - Layer threejs objects
 * {
 *    layerName:[threejsObject1,threejsObject2,threejsObject3,...] (THREE.Point/Line/Mesh)
 * }
 */
/**
 * "dwg" is short for "drawing", it is a file format saved by AutoCAD.
 * And "dxf" is data exchange format, which can be converted from a dwg file.
 * We cannot read dwg directly, and need to convert it to dxf first via ODA.
 *
 * Supported dxf version: AutoCAD 2018. Both binary and ascii are supported.
 *
 * Json Encoding: UTF-8 encoding without BOM
 *
 * Coordinate system: right-handed, y-up
 *
 * About units:
 * - The unit of distance follows the master dxf file's unit
 * - The unit of area follows the master dxf file's unit
 * - The unit of angle is "degree", counterclockwise
 * - The unit of time is "second"
 *
 * Color: use rgb/rgba, values between 0-1
 *
 * About Measurement in DxfViewer:
 * - A measurement is generated by DxfViewer.
 * - Measurements data should be stored by users, so users can restore measurements data into DxfViewer later.
 * - DxfViewer manages measurements data, it can be created, removed, hidden, etc.
 * - DxfViewer doesn't maintain the relationship between measurement and layout.
 *
 * About Markup in DxfViewer:
 * Markup is pretty similar to measurement.
 *
 * About Hotpoint in DxfViewer:
 * - A hotpoint is created and stored by user.
 * - A hotpoint can be added to, and removed from DxfViewer.
 * - Caller should set a hotpointId that is unique in the session of current DxfViewer.
 * - DxfViewer doesn't hide a hotpoint, user is able to do it.
 * - DxfViewer doesn't maintain the relationship between hotpoint and layout.
 *
 * About layouts
 * - Each layout has its own home view.
 * - When switching to another layout, it clears all measurements, markups and hotpoints.
 * - When switching to another layout, it deactivates any in-progress operation like measurement, markup, etc.
 *
 * About overlay
 * - It supports to add as many models as user want, as long as the browser has sufficient memory, cpu/gpu, etc.
 * - The first model is called "master" model, others are called "overlay" models.
 * - It ignores an overlay model's paper space.
 * - An overlay model's unit should be converted to master model's unit if they are not the same.
 * - We'll append modelId as prefix for getLayers()
 *
 * About comparision
 * - It compares just "Model" spaces.
 * - It compares entities with the same handles and types.
 * - It compares entities' geometries, positions, scales, etc.
 * - It ignores a layer's visibility, freeze settings.
 * - It ignores an entity's properties, like linetype, line width, fill pattern, font, color, etc.
 * - It ignores spatial filters (xclip) of block references.
 * - It ignores layer relative operations, like moving an entity to another layer, changing a layer color, etc.
 * - By default, an "Added" entity is rendered in green, a "Removed" entity is in red, a "Modified" entity is composed by two parts, one "Removed" and another "Added".
 *
 * About undo/redo
 * - It supports undo/redo for measurement and markup operations. E.g., creating/deleting/moving a markup.
 * - Setting/removing a batch of measurements or markups will be taken as one operation.
 * - Switching to another layout clears all undo/redo history.
 *
 * About OSnap
 * - It supports snapping to the end points and middle point of a line.
 * - It supports snapping to the intersection point of two lines.
 * - It supports snapping to the foot of perpendicular against a line.
 * - It supports snapping to any point along a line.
 *
 * @example
 * ``` typescript
 * const viewerCfg = {
 *     containerId: "myCanvas",
 *     enableSpinner: true,
 *     enableLayoutBar: true,
 * };
 * const modelCfg = {
 *     modelId: "id_0",
 *     name: "sample",
 *     src: "http://www.abc.com/sample.dxf",
 * }
 * const fontFiles = ["http://www.abc.com/hztxt.shx", "http://www.abc.com/simplex.shx"];
 *
 * const viewer = new DxfViewer(viewerCfg);
 * await viewer.setFont(fontFiles);
 * await viewer.loadModelAsync(modelCfg);
 * ```
 */
export declare class DxfViewer extends BaseViewer {
    name: ViewerName;
    enableSelection: boolean;
    loadedModels: Model2d[];
    /**
     * @internal
     */
    masterModelId: string;
    private activeLayoutName;
    private dxfLayoutBar?;
    private layoutInfos;
    private units;
    private enableHideVisuallySmallObjects;
    private sortedHidableObjects;
    private lastCameraZoom;
    groundPlane?: THREE.Mesh;
    raycastableObjects?: THREE.Object3D[];
    selectedObject?: THREE.Object3D | Drawable;
    private markupManager?;
    constructor(viewerCfg: DxfViewerConfig);
    get camera(): THREE.OrthographicCamera;
    private setupDefaultEvents;
    protected handleMouseClick(e: EventInfo): void;
    private setDefaultBackground;
    /**
     * Used to indicate how many dxf is loading
     */
    private loadingDxfCount;
    /**
     * @description {en} Loads a dxf file.
     * The first loaded file will be taken as a "master" model.
     * Any other files are non-master, we call "overlay" model.
     * We'll load everything of a master model, including model and paper space.
     * For an overlay model, we'll only load its model space. And its model space can only
     * overly to master model's model space.
     * @description {zh} 加载 dxf 文件。
     * 第一个加载的文件将被视为“主”模型。
     * 任何其他文件都是非主文件，我们称之为“叠加”模型。
     * 我们将加载主模型的所有内容，包括模型和图纸空间。
     * 对于叠加模型，我们只会加载其模型空间。并且它的模型空间只能叠加到主模型的模型空间上。
     * @param modelCfg
     * - {en} The configuration of the model to be loaded.
     * - {zh} 要加载的模型的配置。
     * @param onProgress
     * - {en} A callback function to indicate the loading progress.
     * - {zh} 用于指示加载进度的回调函数。
     * @example
     * ``` typescript
     * const viewerCfg = {
     *     containerId: "myCanvas",
     * };
     * const modelCfg = {
     *     modelId: "id_0",
     *     name: "dxf 0",
     *     src: "http://www.abc.com/sample.dxf",
     * }
     * const viewer = new DxfViewer(viewerCfg);
     * await viewer.loadModelAsync(modelCfg, (event) => {
     *     const progress = (event.loaded * 100) / event.total;
     *     console.log(`Loading progress: ${progress}%`);
     * });
     * console.log("Loaded");
     * ```
     */
    loadModelAsync(modelCfg: DxfModelConfig, onProgress?: (event: ProgressEvent) => void): Promise<void>;
    loadModel(modelCfg: DxfModelConfig, onProgress?: ((event: ProgressEvent<EventTarget>) => void) | undefined): Promise<void>;
    addModel(model: Model2d): void;
    private getDxfUnits;
    private handleOverlayDxf;
    setObjectHighlight(object: THREE.Object3D): void;
    setObjectUnHighlight(object: THREE.Object3D): void;
    clearHighlight(): void;
    clearSelection(): void;
    /**
     * Creates a ground plane which is much bigger than bbox.
     */
    private updateGroundPlane;
    getRaycastableObjects(): THREE.Object3D<THREE.Event>[];
    /**
     * Gets the corresponding viewport by judging that the point is in the viewport
     */
    private getViewportByPoint;
    pickPosition(mousePosition: {
        x: number;
        y: number;
    }): THREE.Vector3 | undefined;
    /**
     * @description {en} Activates a layout.
     * @description {zh} 激活布局。
     * @param layoutName
     * - {en} The name of the layout to be activated.
     * - {zh} 要激活的布局名称。
     * @example
     * ```typescript
     * viewer.activateLayout('Layout1');
     * ```
     */
    activateLayout(layoutName?: string): void;
    private getLayoutExtentEx;
    private getActiveLayoutInfo;
    private getLayoutByName;
    /**
     * @description {en} Gets layout names of the master model.
     * @description {zh} 获取主模型的布局名称。
     * @returns
     * - {en} Layout names of the master model.
     * - {zh} 主模型的布局名称。
     * @example
     * ```typescript
     * const layoutNames = dxfViewer.getLayoutNames();
     * console.log(layoutNames); // ['Model', 'Layout1', 'Layout2']
     * ```
     */
    getLayoutNames(): string[];
    /**
     * Gets LayoutInfo by layoutName. It creats LayoutInfo if doesn't exist.
     */
    private getLayoutInfo;
    goToHomeView(): void;
    zoomToBBox(bbox: THREE.Box3): void;
    /**
     * @description {en} Gets current view extent.
     * This is useful for user to save this value as a viewpoint, and jump to this viewpoint next time.
     * @description {zh} 获取当前视图范围。
     * 用户可使用该接口获取当前视口范围，并在适当的场景下跳转到该视口范围。
     * @example
     * ``` typescript
     * const box = viewer.getCurrentViewExtent();
     * console.log("Current view extent:", box);
     * ```
     */
    getCurrentViewExtent(): Box2;
    /**
     * Gets hit result by Normalized Device Coordinates.
     * Lower left coordinate: (-1, -1)
     * Upper right coordinate: (1, 1)
     */
    protected getHitResultByNdcCoordinate(coord: Vector2): Vector2 | undefined;
    /**
     * Gets mouse hit result in world coordinate
     * @example
     * ``` typescript
     * document.addEventListener("click", (event) => {
     *     const result = viewer.getHitResult(event);
     *     const loc = result?.location;
     *     if (loc) {
     *         console.log(`Clicked at x: ${loc[0]}, y: ${loc[1]}`);
     *     }
     * });
     * ```
     * @internal
     */
    getHitResult(event: MouseEvent | PointerEvent | EventInfo): Vector2 | undefined;
    /** markup start **/
    /**
     * @internal
     */
    getMarkupManager(): MarkupManager | undefined;
    /**
     * @description {en} Activates markup feature.
     * @description {zh} 激活标注功能。
     * @param type
     * - {en} markup type.
     * - {zh} 标注类型。
     * @example
     * ``` typescript
     * const markupType = MarkupType.Arrow;
     * viewer.activateMarkup(markupType);
     * ```
     * @deprecated
     */
    activateMarkup(type: MarkupType): void;
    /**
     * @description {en} Deactivates markup feature.
     * @description {zh} 退出标注功能。
     * @example
     * ``` typescript
     * viewer.deactivateMarkup();
     * ```
     */
    deactivateMarkup(): void;
    /**
     * @description {en} Gets active markup type.
     * @description {zh} 获取激活的标注类型。
     * @returns
     * - {en} markup type.
     * - {zh} 标注类型。
     * @example
     * ``` typescript
     * const markupType = viewer.getActiveMarkupType();
     * console.log(markupType);
     * ```
     */
    getActiveMarkupType(): MarkupType | undefined;
    /**
     * Set markup stroke color
     * @internal
     */
    setMarkupLineColor(r: number, g: number, b: number, a: number): void;
    /**
     * @internal
     */
    getMarkupLineColor(): number[] | undefined;
    /**
     * Set markup fill color
     * @internal
     */
    setMarkupFillColor(r: number, g: number, b: number, a: number): void;
    /**
     * @internal
     */
    getMarkupFillColor(): number[] | undefined;
    /**
     * Set markup stroke line width
     * @internal
     */
    setMarkupLineWidth(lineWidth: number): void;
    /**
     * @internal
     */
    getMarkupLineWidth(): number | undefined;
    /**
     * Set markup font size
     * @internal
     */
    setMarkupFontSize(fontSize: number): void;
    /**
     * @internal
     */
    getMarkupFontSize(): number | undefined;
    /**
     * @description {en} Gets all markups.
     * @description {zh} 获取所有标注数据。
     * @returns
     * - {en} markup data array.
     * - {zh} 标注数据数组。
     * @example
     * ``` typescript
     * const markupData = viewer.getMarkups();
     * console.log(markupData);
     * ```
     */
    getMarkups(): MarkupData[];
    /**
     * @description {en} Adds markups to active layout.
     * @description {zh} 添加标注到当前布局。
     * @param markupDataArray
     * - {en} markup data array.
     * - {zh} 标注数据数组。
     * @example
     * ``` typescript
     * const markupData = [{
     *     type: "ArrowMarkup",
     *     id: "c6ea70a3-ddb0-4dd0-87c8-bd2491936428",
     *     lineWidth: 2,
     *     strokeStyle: "#ff0000",
     *     fillStyle: "#ff000030",
     *     points: [[0, 0], [1000, 1000]],
     * }];
     * viewer.setMarkups(markupData);
     * ```
     */
    setMarkups(markupDataArray: MarkupData[]): void;
    /**
     * Sets a markup's visibility by id.
     * Note that, the markup should belong to active layout. You shouldn't update a markup of an inactive layout.
     * @internal
     */
    setMarkupVisibility(id: string, visible: boolean): boolean;
    /**
     * @description {en} Updates a markup.
     * @description {zh} 更新标注。
     * @param {MarkupData} markup
     * - {en} markup data.
     * - {zh} 标注数据。
     * @returns
     * - {en} Whether update successfully, true means success, false means failure.
     * - {zh} 是否更新成功，true表示成功，false表示失败。
     * @example
     * ``` typescript
     * const markupData = {
     *    type: "ArrowMarkup",
     *    id: "c6ea70a3-ddb0-4dd0-87c8-bd2491936428",
     *    lineWidth: 3,
     *    strokeStyle: "#ff0000",
     *    fillStyle: "#ff000030",
     *    points: [[0, 0], [1000, 1000]],
     * };
     * viewer.updateMarkup(markupData);
     */
    updateMarkup(markup: MarkupData): boolean;
    /**
     * @description {en} Removes a markup by markup id.
     * @description {zh} 根据标注id删除标注。
     * @param {string} id
     * - {en} markup id.
     * - {zh} 标注id。
     * @returns
     * - {en} Whether remove successfully, true means success, false means failure.
     * - {zh} 是否删除成功，true表示成功，false表示失败。
     * @example
     * ``` typescript
     * const markupId = "c6ea70a3-ddb0-4dd0-87c8-bd2491936428";
     * viewer.removeMarkup(markupId);
     * ```
     */
    removeMarkup(id: string): boolean;
    /**
     * @description {en} Clears markups.
     * @description {zh} 清除所有标注。
     * @example
     * ``` typescript
     * viewer.clearMarkups();
     * ```
     */
    clearMarkups(): void;
    /** markup end **/
    /**
     * @description {en} Gets active layout.
     * @description {zh} 获取当前布局。
     * @returns
     * - {en} Active layout name or undefined.
     * - {zh} 当前激活的布局名称或undefined。
     * @example
     * ``` typescript
     * const activeLayout = viewer.getActiveLayoutName();
     * console.log(activeLayout);
     * ```
     */
    getActiveLayoutName(): string | undefined;
    zoomIn(step?: number): void;
    zoomOut(step?: number): void;
    /**
     * @description {en} Gets dxf layers.
     * @description {zh} 获取dxf图层。
     * @returns
     * - {en} Dxf layers.
     * - {zh} dxf图层。
     * @example
     * ``` typescript
     * const dxfLayers = viewer.getLayers();
     * for (let i = 0; i < dxfLayers.length; ++i) {
     *     const layers = dxfLayers[i].layers;
     *     const layerNames = Object.keys(layers).sort();
     *     console.log(layerNames);
     * }
     * ```
     */
    getLayers(): (DxfLayers | PdfLayers)[];
    /**
     * Sets model's (aka, a dxf file) visibility.
     * @throws Throws exception if modelId doesn't exist.
     * @internal
     */
    setModelVisibility(modelId: string, visible: boolean): void;
    /**
     * @description {en} Sets layer's visibility.
     * @description {zh} 设置图层的可见性。
     * @param layerName
     * - {en} Layer's name to show or hide.
     * - {zh} 要显示或隐藏的图层名称。
     * @param visible
     * - {en} Layer's target visibility.
     * - {zh} 图层的目标可见性。
     * @param modelId
     * - {en} Useful when more than one model is loaded, if not specified, will use the master model.
     * - {zh} 当加载了多个模型时有用，如果未指定，将使用主模型。
     * @throws Error
     * - {en}: Throws exception if given modelId doesn't exist.
     * - {zh} 如果给定的modelId不存在，则抛出异常。
     * @example
     * ``` typescript
     * // Hides layer "0"
     * viewer.setLayerVisibility("0", false);
     * ```
     */
    setLayerVisibility(layerName: string, visible: boolean, modelId?: string): void;
    /**
     * Sets layer's opacity
     * @internal
     */
    setLayerOpacity(layerName: string, opacity: number, modelId?: string): void;
    /**
     * Sets layer's color
     * @throws Throws exception if layer doesn't exist.
     * @internal
     */
    setLayerColor(layerName: string, color: number, modelId?: string): void;
    /**
     * Resets a layer's color.
     * @internal
     */
    resetLayerColor(layerName: string, modelId?: string): void;
    private getVisiblePixelSize;
    private setLayoutHidableObjectArray;
    /**
     * Updates raycaster threshold to a proper value, so user can easily pick points and lines
     */
    private updateRaycasterThreshold;
    /**
     * Updates hidable objects' visibility once camera.zoom changed.
     */
    private updateHidableObjectsVisibility;
    /**
     * Updates camera zoom value for shader materials, which are created in DxfLoader
     */
    private updateCameraZoomUniform;
}
