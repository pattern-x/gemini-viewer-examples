import * as THREE from "three";
import { BaseMarkup } from "./BaseMarkup";
import { MarkupType } from "./Constants";
import { CanvasRender, DrawableData } from "../../core/canvas";
import type { EventInfo, InputManager } from "../../core/input/InputManager";
import { Event } from "../../core/utils";
import type { BaseViewer } from "../../core/viewers";
declare type MarkupEvents = {
    StartDraw: BaseMarkup;
    EndDraw: BaseMarkup;
    EndEdit: BaseMarkup;
};
export declare class MarkupManager extends Event<MarkupEvents> {
    private viewer;
    private inputManager;
    overlayRender?: CanvasRender;
    private drawableList;
    private lineWidth;
    private lineColor;
    private fillColor;
    private fontSize;
    protected mouseDown: boolean;
    protected mouseDownPositionX?: number;
    protected mouseDownPositionY?: number;
    protected mousedownPoint?: THREE.Vector2;
    private isSelectLeaderText;
    private tempKey?;
    private tempTouch?;
    private tempArrowKeys?;
    private selectedShape?;
    private type?;
    private isDrawing;
    private initialDataForEditing?;
    private creatingShape?;
    private tempPoints;
    private activated;
    protected exitButton?: HTMLButtonElement;
    constructor(viewer: BaseViewer, input: InputManager);
    get viewerCanvas(): HTMLCanvasElement;
    get camera(): THREE.OrthographicCamera | THREE.PerspectiveCamera;
    get raycaster(): THREE.Raycaster;
    setMarkupVisibility(id: string, visible: boolean): boolean;
    setMarkupsVisibility(visible: boolean): void;
    clearAll(): void;
    isMarkupActive(): boolean;
    protected createMobileExitButton(): HTMLButtonElement;
    activate(): void;
    deactivate(): void;
    getActiveMarkupType(): MarkupType | undefined;
    setDrawType(type: MarkupType): void;
    setLineWidth(linewidth: number): void;
    getLineWidth(): number;
    setLineColor(color: number[]): void;
    getLineColor(): number[];
    setFillColor(color: number[]): void;
    getFillColor(): number[];
    setFontSize(fontSize: number): void;
    getFontSize(): number;
    pickPositionByScreenPoint(p: THREE.Vector2): THREE.Vector3 | undefined;
    pickThreejsPositionByMouse(e: EventInfo): THREE.Vector3 | undefined;
    handleDbClick: () => void;
    handleInputMousemove: (e: MouseEvent) => void;
    mousedown: (e: EventInfo) => void;
    mousemove: (e: EventInfo) => void;
    mouseup: (e: EventInfo) => void;
    keydown: (e: EventInfo) => void;
    confirmToRemove(isConfirm: boolean): void;
    isEditing(): boolean;
    endEdit(selectMarkup: BaseMarkup): void;
    endDraw(createdMarkup?: BaseMarkup): void;
    cancelDraw(createdMarkup?: BaseMarkup): void;
    reset(): void;
    render(): void;
    addMarkup(markup: BaseMarkup, needFireEvent?: boolean): void;
    updateMarkup(markup: BaseMarkup, newData: DrawableData, needFireEvent?: boolean): void;
    removeMarkup(markup: BaseMarkup, needFireEvent?: boolean): void;
    removeMarkupById(id: string): boolean;
    createMarkup(data: DrawableData): BaseMarkup;
    getMarkupById(id: string): BaseMarkup;
    getMarkupData(): DrawableData[];
    setMarkupData(markupDatas: DrawableData[]): void;
    private isCreateLineMode;
    private isCreateDotMode;
    private isCreateTextMode;
    private isCreateShapeMode;
    private drawShape;
    private drawLine;
    private drawText;
    destroy(): void;
}
export {};
